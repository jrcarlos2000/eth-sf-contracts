{
  "language": "Solidity",
  "sources": {
    "contracts/Contract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport { ByteHasher } from './helpers/ByteHasher.sol';\nimport { IWorldID } from './interfaces/IWorldID.sol';\n\ncontract Contract {\n    using ByteHasher for bytes;\n\n    ///////////////////////////////////////////////////////////////////////////////\n    ///                                  ERRORS                                ///\n    //////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Thrown when attempting to reuse a nullifier\n    error InvalidNullifier();\n\n    /// @dev The WorldID instance that will be used for verifying proofs\n    IWorldID internal immutable worldId;\n\n    /// @dev The application's action ID\n    uint256 internal immutable actionId;\n\n    /// @dev The WorldID group ID (1)\n    uint256 internal immutable groupId = 1;\n\n    /// @dev Whether a nullifier hash has been used already. Used to prevent double-signaling\n    mapping(uint256 => bool) internal nullifierHashes;\n\n    /// @param _worldId The WorldID instance that will verify the proofs\n    /// @param _actionId The action ID for your application\n    constructor(IWorldID _worldId, string memory _actionId) {\n        worldId = _worldId;\n        actionId = abi.encodePacked(_actionId).hashToField();\n    }\n\n    /// @param input User's input, used as the signal. Could be something else! (see README)\n    /// @param root The of the Merkle tree, returned by the SDK.\n    /// @param nullifierHash The nullifier for this proof, preventing double signaling, returned by the SDK.\n    /// @param proof The zero knowledge proof that demostrates the claimer is registered with World ID, returned by the SDK.\n    /// @dev Feel free to rename this method however you want! We've used `claim`, `verify` or `execute` in the past.\n    function verifyAndExecute(\n        address input,\n        uint256 randomNumber,\n        uint256 root,\n        uint256 nullifierHash,\n        uint256[8] calldata proof\n    ) public {\n        // first, we make sure this person hasn't done this before\n        if (nullifierHashes[nullifierHash]) revert InvalidNullifier();\n\n        // then, we verify they're registered with WorldID, and the input they've provided is correct\n        worldId.verifyProof(\n            root,\n            groupId,\n            abi.encodePacked(input,randomNumber).hashToField(),\n            nullifierHash,\n            actionId,\n            proof\n        );\n\n        // finally, we record they've done this, so they can't do it again (proof of uniqueness)\n        nullifierHashes[nullifierHash] = true;\n\n        // your logic here, make sure to emit some kind of event afterwards!\n    }\n\n    function getWorldIDAddr () external view returns(address){\n        return address(worldId);\n    }\n}\n"
    },
    "contracts/helpers/ByteHasher.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nlibrary ByteHasher {\n    /// @dev Creates a keccak256 hash of a bytestring.\n    /// @param value The bytestring to hash\n    /// @return The hash of the specified value\n    /// @dev `>> 8` makes sure that the result is included in our field\n    function hashToField(bytes memory value) internal pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(value))) >> 8;\n    }\n}\n"
    },
    "contracts/interfaces/IWorldID.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\ninterface IWorldID {\n    /// @notice Reverts if the zero-knowledge proof is invalid.\n    /// @param root The of the Merkle tree\n    /// @param groupId The id of the Semaphore group\n    /// @param signalHash A keccak256 hash of the Semaphore signal\n    /// @param nullifierHash The nullifier hash\n    /// @param externalNullifierHash A keccak256 hash of the external nullifier\n    /// @param proof The zero-knowledge proof\n    /// @dev  Note that a double-signaling check is not included here, and should be carried by the caller.\n    function verifyProof(\n        uint256 root,\n        uint256 groupId,\n        uint256 signalHash,\n        uint256 nullifierHash,\n        uint256 externalNullifierHash,\n        uint256[8] calldata proof\n    ) external view;\n}\n"
    },
    "contracts/MockWorldID.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport { Verifier } from \"./semaphore/contracts/base/Verifier.sol\";\nimport { IWorldID } from \"./interfaces/IWorldID.sol\";\nimport { SemaphoreCore } from \"./semaphore/contracts/base/SemaphoreCore.sol\";\nimport { SemaphoreGroups } from \"./semaphore/contracts/base/SemaphoreGroups.sol\";\nimport {\n    IncrementalBinaryTree,\n    IncrementalTreeData\n} from './zk-kit/packages/incremental-merkle-tree.sol/contracts/IncrementalBinaryTree.sol';\n\n/// @title Semaphore Group Manager\n/// @author Miguel Piedrafita\n/// @notice A simple implementation of a ZK-based identity group manager using Semaphore\ncontract MockWorldID is IWorldID, SemaphoreCore, Verifier, SemaphoreGroups {\n    using IncrementalBinaryTree for IncrementalTreeData;\n\n    ///////////////////////////////////////////////////////////////////////////////\n    ///                                  ERRORS                                 ///\n    //////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Thrown when trying to update or create groups without being the manager\n    error Unauthorized();\n\n    /// @notice Thrown when trying to create a group with id 0, since this can later cause issues with root history verification.\n    error InvalidId();\n\n    /// @notice Thrown when attempting to validate a root that doesn't belong to the specified group.\n    error InvalidRoot();\n\n    /// @notice Thrown when attempting to validate a root that has expired.\n    error ExpiredRoot();\n\n    /// @notice Thrown when attempting to validate a root that has yet to be added to the root history.\n    error NonExistentRoot();\n\n    /// @notice Thrown when trying to insert the initial leaf into a given group.\n    error InvalidCommitment();\n\n    ///////////////////////////////////////////////////////////////////////////////\n    ///                                 STRUCTS                                  ///\n    //////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Stores the group a root belongs to, along with a timestamp for when it was generated\n    /// @param groupId The group this root belongs to\n    /// @param timestamp The time the root was generated at\n    struct RootHistory {\n        uint128 groupId;\n        uint128 timestamp;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    ///                              CONFIG STORAGE                            ///\n    //////////////////////////////////////////////////////////////////////////////\n\n    /// @notice The amount of time an outdated root for a group is considered as valid\n    /// @dev This prevents proofs getting invalidated in the mempool by another tx modifying the group\n    uint256 internal constant ROOT_HISTORY_EXPIRY = 1 hours;\n\n    /// @notice Represents the initial leaf in an empty merkle tree\n    /// @dev Prevents the empty leaf from being inserted into the root history.\n    uint256 internal constant EMPTY_LEAF = uint256(0);\n\n    /// @notice The address that manages this contract, which is allowed to update and create groups.\n    address public manager = msg.sender;\n\n    mapping(uint256 => RootHistory) internal rootHistory;\n\n    mapping(uint256 => uint256) public latestRoots;\n\n    ///////////////////////////////////////////////////////////////////////////////\n    ///                                EVENTS                                  ///\n    //////////////////////////////////////////////////////////////////////////////\n\n    event MemberAdded(uint256 indexed groupId, uint256 leafIndex, uint256 identityCommitment, uint256 newRoot);\n\n    ///////////////////////////////////////////////////////////////////////////////\n    ///                          GROUP MANAGEMENT LOGIC                        ///\n    //////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Create a new identity group. Can only be called by the manager\n    /// @param groupId The id of the group\n    /// @param depth The depth of the tree\n    function createGroup(\n        uint256 groupId,\n        uint8 depth\n    ) public {\n        if (msg.sender != manager) revert Unauthorized();\n\n        _createGroup(groupId, depth, EMPTY_LEAF);\n    }\n\n    /// @notice Add a new member to an existing group. Can only be called by the manager\n    /// @param groupId The id of the group\n    /// @param identityCommitment The identity commitment for the new member\n    function addMember(uint256 groupId, uint256 identityCommitment) public {\n        if (msg.sender != manager) revert Unauthorized();\n\n        if (identityCommitment == EMPTY_LEAF) revert InvalidCommitment();\n\n        uint256 leafIndex = groups[groupId].insert(identityCommitment);\n\n        uint256 root = getRoot(groupId);\n        rootHistory[root] = RootHistory({\n            groupId: uint128(groupId),\n            timestamp: uint128(block.timestamp)\n        });\n\n        latestRoots[groupId] = root;\n\n        emit MemberAdded(groupId, leafIndex, identityCommitment, root);\n    }\n\n    /// @notice Remove a member from an existing group. Can only be called by the manager\n    /// @param groupId The id of the group\n    /// @param identityCommitment The identity commitment for the member that'll be removed\n    /// @param proofSiblings An array of the sibling nodes of the proof of membership\n    /// @param proofPathIndices The path of the proof of membership\n    function removeMember(\n        uint256 groupId,\n        uint256 identityCommitment,\n        uint256[] calldata proofSiblings,\n        uint8[] calldata proofPathIndices\n    ) public {\n        if (msg.sender != manager) revert Unauthorized();\n        if (getDepth(groupId) == 0) revert InvalidId();\n\n        groups[groupId].remove(identityCommitment, proofSiblings, proofPathIndices);\n\n        uint256 root = getRoot(groupId);\n        rootHistory[root] = RootHistory({\n            groupId: uint128(groupId),\n            timestamp: uint128(block.timestamp)\n        });\n\n        latestRoots[groupId] = root;\n\n        emit MemberRemoved(groupId, identityCommitment, groups[groupId].root);\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    ///                          PROOF VALIDATION LOGIC                        ///\n    //////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Reverts if the zero-knowledge proof is invalid.\n    /// @param root The of the Merkle tree\n    /// @param groupId The id of the Semaphore group\n    /// @param signalHash A keccak256 hash of the Semaphore signal\n    /// @param nullifierHash The nullifier hash\n    /// @param externalNullifierHash A keccak256 hash of the external nullifier\n    /// @param proof The zero-knowledge proof\n    /// @dev  Note that a double-signaling check is not included here, and should be carried by the caller.\n    function verifyProof(\n        uint256 root,\n        uint256 groupId,\n        uint256 signalHash,\n        uint256 nullifierHash,\n        uint256 externalNullifierHash,\n        uint256[8] calldata proof\n    ) public view {\n        uint256[4] memory publicSignals = [root, nullifierHash, signalHash, externalNullifierHash];\n\n        if (checkValidRoot(groupId, root)) {\n            verifyProof(\n                [proof[0], proof[1]],\n                [[proof[2], proof[3]], [proof[4], proof[5]]],\n                [proof[6], proof[7]],\n                publicSignals\n            );\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    ///                               CONFIG LOGIC                             ///\n    //////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Transfer management access to a different address, or to 0x0 to renounce. Can only be called by the manager\n    /// @param newManager The address of the new manager\n    function transferAccess(address newManager) public {\n        if (msg.sender != manager) revert Unauthorized();\n\n        manager = newManager;\n    }\n    ///////////////////////////////////////////////////////////////////////////////\n    ///                          VIEW FUNCTIONS                                ///\n    //////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Checks if a given root value is valid and has been added to the root history\n    /// @param groupId The id of the group\n    /// @param root  The root of a given identity group\n    function checkValidRoot(uint256 groupId, uint256 root) public view returns (bool) {\n        if (root != latestRoots[groupId] || latestRoots[groupId] == EMPTY_LEAF) {\n            RootHistory memory rootData = rootHistory[root];\n\n            if (\n                block.timestamp - rootData.timestamp > ROOT_HISTORY_EXPIRY\n            ) revert ExpiredRoot();\n\n            if (\n                rootData.groupId == 0 && rootData.timestamp == 0\n            ) revert NonExistentRoot();\n        }\n\n        return true;\n    }\n\n}"
    },
    "contracts/semaphore/contracts/base/Verifier.sol": {
      "content": "//\n// Copyright 2017 Christian Reitwiessner\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n// 2019 OKIMS\n//      ported to solidity 0.6\n//      fixed linter warnings\n//      added requiere error messages\n//\n// 2021 Remco Bloemen\n//       cleaned up code\n//       added InvalidProve() error\n//       always revert with InvalidProof() on invalid proof\n//       make Pairing strict\n//\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.4;\n\nlibrary Pairing {\n  error InvalidProof();\n\n  // The prime q in the base field F_q for G1\n  uint256 constant BASE_MODULUS = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n  // The prime moludus of the scalar field of G1.\n  uint256 constant SCALAR_MODULUS = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n  struct G1Point {\n    uint256 X;\n    uint256 Y;\n  }\n\n  // Encoding of field elements is: X[0] * z + X[1]\n  struct G2Point {\n    uint256[2] X;\n    uint256[2] Y;\n  }\n\n  /// @return the generator of G1\n  function P1() internal pure returns (G1Point memory) {\n    return G1Point(1, 2);\n  }\n\n  /// @return the generator of G2\n  function P2() internal pure returns (G2Point memory) {\n    return\n      G2Point(\n        [\n          11559732032986387107991004021392285783925812861821192530917403151452391805634,\n          10857046999023057135944570762232829481370756359578518086990519993285655852781\n        ],\n        [\n          4082367875863433681332203403145435568316851327593401208105741076214120093531,\n          8495653923123431417604973247489272438418190587263600148770280649306958101930\n        ]\n      );\n  }\n\n  /// @return r the negation of p, i.e. p.addition(p.negate()) should be zero.\n  function negate(G1Point memory p) internal pure returns (G1Point memory r) {\n    if (p.X == 0 && p.Y == 0) return G1Point(0, 0);\n    // Validate input or revert\n    if (p.X >= BASE_MODULUS || p.Y >= BASE_MODULUS) revert InvalidProof();\n    // We know p.Y > 0 and p.Y < BASE_MODULUS.\n    return G1Point(p.X, BASE_MODULUS - p.Y);\n  }\n\n  /// @return r the sum of two points of G1\n  function addition(G1Point memory p1, G1Point memory p2) internal view returns (G1Point memory r) {\n    // By EIP-196 all input is validated to be less than the BASE_MODULUS and form points\n    // on the curve.\n    uint256[4] memory input;\n    input[0] = p1.X;\n    input[1] = p1.Y;\n    input[2] = p2.X;\n    input[3] = p2.Y;\n    bool success;\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\n    }\n    if (!success) revert InvalidProof();\n  }\n\n  /// @return r the product of a point on G1 and a scalar, i.e.\n  /// p == p.scalar_mul(1) and p.addition(p) == p.scalar_mul(2) for all points p.\n  function scalar_mul(G1Point memory p, uint256 s) internal view returns (G1Point memory r) {\n    // By EIP-196 the values p.X and p.Y are verified to less than the BASE_MODULUS and\n    // form a valid point on the curve. But the scalar is not verified, so we do that explicitelly.\n    if (s >= SCALAR_MODULUS) revert InvalidProof();\n    uint256[3] memory input;\n    input[0] = p.X;\n    input[1] = p.Y;\n    input[2] = s;\n    bool success;\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\n    }\n    if (!success) revert InvalidProof();\n  }\n\n  /// Asserts the pairing check\n  /// e(p1[0], p2[0]) *  .... * e(p1[n], p2[n]) == 1\n  /// For example pairing([P1(), P1().negate()], [P2(), P2()]) should succeed\n  function pairingCheck(G1Point[] memory p1, G2Point[] memory p2) internal view {\n    // By EIP-197 all input is verified to be less than the BASE_MODULUS and form elements in their\n    // respective groups of the right order.\n    if (p1.length != p2.length) revert InvalidProof();\n    uint256 elements = p1.length;\n    uint256 inputSize = elements * 6;\n    uint256[] memory input = new uint256[](inputSize);\n    for (uint256 i = 0; i < elements; i++) {\n      input[i * 6 + 0] = p1[i].X;\n      input[i * 6 + 1] = p1[i].Y;\n      input[i * 6 + 2] = p2[i].X[0];\n      input[i * 6 + 3] = p2[i].X[1];\n      input[i * 6 + 4] = p2[i].Y[0];\n      input[i * 6 + 5] = p2[i].Y[1];\n    }\n    uint256[1] memory out;\n    bool success;\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      success := staticcall(sub(gas(), 2000), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\n    }\n    if (!success || out[0] != 1) revert InvalidProof();\n  }\n}\n\ncontract Verifier {\n  using Pairing for *;\n\n  struct VerifyingKey {\n    Pairing.G1Point alfa1;\n    Pairing.G2Point beta2;\n    Pairing.G2Point gamma2;\n    Pairing.G2Point delta2;\n    Pairing.G1Point[] IC;\n  }\n\n  struct Proof {\n    Pairing.G1Point A;\n    Pairing.G2Point B;\n    Pairing.G1Point C;\n  }\n\n  function verifyingKey() internal pure returns (VerifyingKey memory vk) {\n    vk.alfa1 = Pairing.G1Point(\n      20491192805390485299153009773594534940189261866228447918068658471970481763042,\n      9383485363053290200918347156157836566562967994039712273449902621266178545958\n    );\n\n    vk.beta2 = Pairing.G2Point(\n      [\n        4252822878758300859123897981450591353533073413197771768651442665752259397132,\n        6375614351688725206403948262868962793625744043794305715222011528459656738731\n      ],\n      [\n        21847035105528745403288232691147584728191162732299865338377159692350059136679,\n        10505242626370262277552901082094356697409835680220590971873171140371331206856\n      ]\n    );\n    vk.gamma2 = Pairing.G2Point(\n      [\n        11559732032986387107991004021392285783925812861821192530917403151452391805634,\n        10857046999023057135944570762232829481370756359578518086990519993285655852781\n      ],\n      [\n        4082367875863433681332203403145435568316851327593401208105741076214120093531,\n        8495653923123431417604973247489272438418190587263600148770280649306958101930\n      ]\n    );\n    vk.delta2 = Pairing.G2Point(\n      [\n        12599857379517512478445603412764121041984228075771497593287716170335433683702,\n        7912208710313447447762395792098481825752520616755888860068004689933335666613\n      ],\n      [\n        11502426145685875357967720478366491326865907869902181704031346886834786027007,\n        21679208693936337484429571887537508926366191105267550375038502782696042114705\n      ]\n    );\n    vk.IC = new Pairing.G1Point[](5);\n\n    vk.IC[0] = Pairing.G1Point(\n      19918517214839406678907482305035208173510172567546071380302965459737278553528,\n      7151186077716310064777520690144511885696297127165278362082219441732663131220\n    );\n\n    vk.IC[1] = Pairing.G1Point(\n      690581125971423619528508316402701520070153774868732534279095503611995849608,\n      21271996888576045810415843612869789314680408477068973024786458305950370465558\n    );\n\n    vk.IC[2] = Pairing.G1Point(\n      16461282535702132833442937829027913110152135149151199860671943445720775371319,\n      2814052162479976678403678512565563275428791320557060777323643795017729081887\n    );\n\n    vk.IC[3] = Pairing.G1Point(\n      4319780315499060392574138782191013129592543766464046592208884866569377437627,\n      13920930439395002698339449999482247728129484070642079851312682993555105218086\n    );\n\n    vk.IC[4] = Pairing.G1Point(\n      3554830803181375418665292545416227334138838284686406179598687755626325482686,\n      5951609174746846070367113593675211691311013364421437923470787371738135276998\n    );\n  }\n\n  /// @dev Verifies a Semaphore proof. Reverts with InvalidProof if the proof is invalid.\n  function verifyProof(\n    uint256[2] memory a,\n    uint256[2][2] memory b,\n    uint256[2] memory c,\n    uint256[4] memory input\n  ) public view {\n    // If the values are not in the correct range, the Pairing contract will revert.\n    Proof memory proof;\n    proof.A = Pairing.G1Point(a[0], a[1]);\n    proof.B = Pairing.G2Point([b[0][0], b[0][1]], [b[1][0], b[1][1]]);\n    proof.C = Pairing.G1Point(c[0], c[1]);\n\n    VerifyingKey memory vk = verifyingKey();\n\n    // Compute the linear combination vk_x of inputs times IC\n    if (input.length + 1 != vk.IC.length) revert Pairing.InvalidProof();\n    Pairing.G1Point memory vk_x = vk.IC[0];\n    vk_x = Pairing.addition(vk_x, Pairing.scalar_mul(vk.IC[1], input[0]));\n    vk_x = Pairing.addition(vk_x, Pairing.scalar_mul(vk.IC[2], input[1]));\n    vk_x = Pairing.addition(vk_x, Pairing.scalar_mul(vk.IC[3], input[2]));\n    vk_x = Pairing.addition(vk_x, Pairing.scalar_mul(vk.IC[4], input[3]));\n\n    // Check pairing\n    Pairing.G1Point[] memory p1 = new Pairing.G1Point[](4);\n    Pairing.G2Point[] memory p2 = new Pairing.G2Point[](4);\n    p1[0] = Pairing.negate(proof.A);\n    p2[0] = proof.B;\n    p1[1] = vk.alfa1;\n    p2[1] = vk.beta2;\n    p1[2] = vk_x;\n    p2[2] = vk.gamma2;\n    p1[3] = proof.C;\n    p2[3] = vk.delta2;\n    Pairing.pairingCheck(p1, p2);\n  }\n}\n"
    },
    "contracts/semaphore/contracts/base/SemaphoreCore.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ISemaphoreCore.sol\";\nimport \"../interfaces/IVerifier.sol\";\n\n/// @title Semaphore core contract.\n/// @notice Minimal code to allow users to signal their endorsement of an arbitrary string.\n/// @dev The following code verifies that the proof is correct and saves the hash of the\n/// nullifier to prevent double-signaling. External nullifier and Merkle trees (i.e. groups) must be\n/// managed externally.\ncontract SemaphoreCore is ISemaphoreCore {\n  /// @dev Gets a nullifier hash and returns true or false.\n  /// It is used to prevent double-signaling.\n  mapping(uint256 => bool) internal nullifierHashes;\n\n  /// @dev Asserts that no nullifier already exists and if the zero-knowledge proof is valid.\n  /// Otherwise it reverts.\n  /// @param signal: Semaphore signal.\n  /// @param root: Root of the Merkle tree.\n  /// @param nullifierHash: Nullifier hash.\n  /// @param externalNullifier: External nullifier.\n  /// @param proof: Zero-knowledge proof.\n  /// @param verifier: Verifier address.\n  function _verifyProof(\n    bytes32 signal,\n    uint256 root,\n    uint256 nullifierHash,\n    uint256 externalNullifier,\n    uint256[8] calldata proof,\n    IVerifier verifier\n  ) internal view {\n    require(!nullifierHashes[nullifierHash], \"SemaphoreCore: you cannot use the same nullifier twice\");\n\n    uint256 signalHash = _hashSignal(signal);\n\n    verifier.verifyProof(\n      [proof[0], proof[1]],\n      [[proof[2], proof[3]], [proof[4], proof[5]]],\n      [proof[6], proof[7]],\n      [root, nullifierHash, signalHash, externalNullifier]\n    );\n  }\n\n  /// @dev Stores the nullifier hash to prevent double-signaling.\n  /// Attention! Remember to call it when you verify a proof if you\n  /// need to prevent double-signaling.\n  /// @param nullifierHash: Semaphore nullifier hash.\n  function _saveNullifierHash(uint256 nullifierHash) internal {\n    nullifierHashes[nullifierHash] = true;\n  }\n\n  /// @dev Creates a keccak256 hash of the signal.\n  /// @param signal: Semaphore signal.\n  /// @return Hash of the signal.\n  function _hashSignal(bytes32 signal) private pure returns (uint256) {\n    return uint256(keccak256(abi.encodePacked(signal))) >> 8;\n  }\n}\n"
    },
    "contracts/semaphore/contracts/base/SemaphoreGroups.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.4;\n\nimport {SNARK_SCALAR_FIELD} from \"./SemaphoreConstants.sol\";\nimport \"../interfaces/ISemaphoreGroups.sol\";\nimport \"../../../zk-kit/packages/incremental-merkle-tree.sol/contracts/IncrementalBinaryTree.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n\n/// @title Semaphore groups contract.\n/// @dev The following code allows you to create groups, add and remove members.\n/// You can use getters to obtain informations about groups (root, depth, number of leaves).\nabstract contract SemaphoreGroups is Context, ISemaphoreGroups {\n  using IncrementalBinaryTree for IncrementalTreeData;\n\n  /// @dev Gets a group id and returns the group/tree data.\n  mapping(uint256 => IncrementalTreeData) internal groups;\n\n  /// @dev Creates a new group by initializing the associated tree.\n  /// @param groupId: Id of the group.\n  /// @param depth: Depth of the tree.\n  /// @param zeroValue: Zero value of the tree.\n  function _createGroup(\n    uint256 groupId,\n    uint8 depth,\n    uint256 zeroValue\n  ) internal virtual {\n    require(groupId < SNARK_SCALAR_FIELD, \"SemaphoreGroups: group id must be < SNARK_SCALAR_FIELD\");\n    require(getDepth(groupId) == 0, \"SemaphoreGroups: group already exists\");\n\n    groups[groupId].init(depth, zeroValue);\n\n    emit GroupCreated(groupId, depth, zeroValue);\n  }\n\n  /// @dev Adds an identity commitment to an existing group.\n  /// @param groupId: Id of the group.\n  /// @param identityCommitment: New identity commitment.\n  function _addMember(uint256 groupId, uint256 identityCommitment) internal virtual {\n    require(getDepth(groupId) != 0, \"SemaphoreGroups: group does not exist\");\n\n    groups[groupId].insert(identityCommitment);\n\n    uint256 root = getRoot(groupId);\n\n    emit MemberAdded(groupId, identityCommitment, root);\n  }\n\n  /// @dev Removes an identity commitment from an existing group. A proof of membership is\n  /// needed to check if the node to be deleted is part of the tree.\n  /// @param groupId: Id of the group.\n  /// @param identityCommitment: Existing identity commitment to be deleted.\n  /// @param proofSiblings: Array of the sibling nodes of the proof of membership.\n  /// @param proofPathIndices: Path of the proof of membership.\n  function _removeMember(\n    uint256 groupId,\n    uint256 identityCommitment,\n    uint256[] calldata proofSiblings,\n    uint8[] calldata proofPathIndices\n  ) internal virtual {\n    require(getDepth(groupId) != 0, \"SemaphoreGroups: group does not exist\");\n\n    groups[groupId].remove(identityCommitment, proofSiblings, proofPathIndices);\n\n    uint256 root = getRoot(groupId);\n\n    emit MemberRemoved(groupId, identityCommitment, root);\n  }\n\n  /// @dev See {ISemaphoreGroups-getRoot}.\n  function getRoot(uint256 groupId) public view virtual override returns (uint256) {\n    return groups[groupId].root;\n  }\n\n  /// @dev See {ISemaphoreGroups-getDepth}.\n  function getDepth(uint256 groupId) public view virtual override returns (uint8) {\n    return groups[groupId].depth;\n  }\n\n  /// @dev See {ISemaphoreGroups-getNumberOfLeaves}.\n  function getNumberOfLeaves(uint256 groupId) public view virtual override returns (uint256) {\n    return groups[groupId].numberOfLeaves;\n  }\n}\n"
    },
    "contracts/zk-kit/packages/incremental-merkle-tree.sol/contracts/IncrementalBinaryTree.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {PoseidonT3} from \"./Hashes.sol\";\n\n// Each incremental tree has certain properties and data that will\n// be used to add new leaves.\nstruct IncrementalTreeData {\n  uint8 depth; // Depth of the tree (levels - 1).\n  uint256 root; // Root hash of the tree.\n  uint256 numberOfLeaves; // Number of leaves of the tree.\n  mapping(uint256 => uint256) zeroes; // Zero hashes used for empty nodes (level -> zero hash).\n  // The nodes of the subtrees used in the last addition of a leaf (level -> [left node, right node]).\n  mapping(uint256 => uint256[2]) lastSubtrees; // Caching these values is essential to efficient appends.\n}\n\n/// @title Incremental binary Merkle tree.\n/// @dev The incremental tree allows to calculate the root hash each time a leaf is added, ensuring\n/// the integrity of the tree.\nlibrary IncrementalBinaryTree {\n  uint8 internal constant MAX_DEPTH = 32;\n  uint256 internal constant SNARK_SCALAR_FIELD =\n    21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n  /// @dev Initializes a tree.\n  /// @param self: Tree data.\n  /// @param depth: Depth of the tree.\n  /// @param zero: Zero value to be used.\n  function init(\n    IncrementalTreeData storage self,\n    uint8 depth,\n    uint256 zero\n  ) public {\n    require(zero < SNARK_SCALAR_FIELD, \"IncrementalBinaryTree: leaf must be < SNARK_SCALAR_FIELD\");\n    require(depth > 0 && depth <= MAX_DEPTH, \"IncrementalBinaryTree: tree depth must be between 1 and 32\");\n\n    self.depth = depth;\n\n    for (uint8 i = 0; i < depth; i++) {\n      self.zeroes[i] = zero;\n      zero = PoseidonT3.poseidon([zero, zero]);\n    }\n\n    self.root = zero;\n  }\n\n  /// @dev Inserts a leaf in the tree.\n  /// @param self: Tree data.\n  /// @param leaf: Leaf to be inserted.\n  function insert(IncrementalTreeData storage self, uint256 leaf) public returns (uint256) {\n    require(leaf < SNARK_SCALAR_FIELD, \"IncrementalBinaryTree: leaf must be < SNARK_SCALAR_FIELD\");\n    require(self.numberOfLeaves < 2**self.depth, \"IncrementalBinaryTree: tree is full\");\n\n    uint256 index = self.numberOfLeaves;\n    uint256 hash = leaf;\n\n    for (uint8 i = 0; i < self.depth; i++) {\n      if (index % 2 == 0) {\n        self.lastSubtrees[i] = [hash, self.zeroes[i]];\n      } else {\n        self.lastSubtrees[i][1] = hash;\n      }\n\n      hash = PoseidonT3.poseidon(self.lastSubtrees[i]);\n      index /= 2;\n    }\n\n    self.root = hash;\n    self.numberOfLeaves += 1;\n    return index;\n  }\n\n  /// @dev Removes a leaf from the tree.\n  /// @param self: Tree data.\n  /// @param leaf: Leaf to be removed.\n  /// @param proofSiblings: Array of the sibling nodes of the proof of membership.\n  /// @param proofPathIndices: Path of the proof of membership.\n  function remove(\n    IncrementalTreeData storage self,\n    uint256 leaf,\n    uint256[] calldata proofSiblings,\n    uint8[] calldata proofPathIndices\n  ) public {\n    require(verify(self, leaf, proofSiblings, proofPathIndices), \"IncrementalBinaryTree: leaf is not part of the tree\");\n\n    uint256 hash = self.zeroes[0];\n\n    for (uint8 i = 0; i < self.depth; i++) {\n      if (proofPathIndices[i] == 0) {\n        if (proofSiblings[i] == self.lastSubtrees[i][1]) {\n          self.lastSubtrees[i][0] = hash;\n        }\n\n        hash = PoseidonT3.poseidon([hash, proofSiblings[i]]);\n      } else {\n        if (proofSiblings[i] == self.lastSubtrees[i][0]) {\n          self.lastSubtrees[i][1] = hash;\n        }\n\n        hash = PoseidonT3.poseidon([proofSiblings[i], hash]);\n      }\n    }\n\n    self.root = hash;\n  }\n\n  /// @dev Verify if the path is correct and the leaf is part of the tree.\n  /// @param self: Tree data.\n  /// @param leaf: Leaf to be removed.\n  /// @param proofSiblings: Array of the sibling nodes of the proof of membership.\n  /// @param proofPathIndices: Path of the proof of membership.\n  /// @return True or false.\n  function verify(\n    IncrementalTreeData storage self,\n    uint256 leaf,\n    uint256[] calldata proofSiblings,\n    uint8[] calldata proofPathIndices\n  ) private view returns (bool) {\n    require(leaf < SNARK_SCALAR_FIELD, \"IncrementalBinaryTree: leaf must be < SNARK_SCALAR_FIELD\");\n    require(\n      proofPathIndices.length == self.depth && proofSiblings.length == self.depth,\n      \"IncrementalBinaryTree: length of path is not correct\"\n    );\n\n    uint256 hash = leaf;\n\n    for (uint8 i = 0; i < self.depth; i++) {\n      require(\n        proofSiblings[i] < SNARK_SCALAR_FIELD,\n        \"IncrementalBinaryTree: sibling node must be < SNARK_SCALAR_FIELD\"\n      );\n\n      if (proofPathIndices[i] == 0) {\n        hash = PoseidonT3.poseidon([hash, proofSiblings[i]]);\n      } else {\n        hash = PoseidonT3.poseidon([proofSiblings[i], hash]);\n      }\n    }\n\n    return hash == self.root;\n  }\n}\n"
    },
    "contracts/semaphore/contracts/interfaces/ISemaphoreCore.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.4;\n\n/// @title SemaphoreCore interface.\n/// @dev Interface of SemaphoreCore contract.\ninterface ISemaphoreCore {\n  /// @notice Emitted when a proof is verified correctly and a new nullifier hash is added.\n  /// @param nullifierHash: Hash of external and identity nullifiers.\n  event NullifierHashAdded(uint256 nullifierHash);\n}\n"
    },
    "contracts/semaphore/contracts/interfaces/IVerifier.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.4;\n\n/// @title Verifier interface.\n/// @dev Interface of Verifier contract.\ninterface IVerifier {\n  function verifyProof(\n    uint256[2] memory a,\n    uint256[2][2] memory b,\n    uint256[2] memory c,\n    uint256[4] memory input\n  ) external view;\n}\n"
    },
    "contracts/semaphore/contracts/base/SemaphoreConstants.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.4;\n\nuint256 constant SNARK_SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n"
    },
    "contracts/semaphore/contracts/interfaces/ISemaphoreGroups.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.4;\n\n/// @title SemaphoreGroups interface.\n/// @dev Interface of a SemaphoreGroups contract.\ninterface ISemaphoreGroups {\n  /// @dev Emitted when a new group is created.\n  /// @param groupId: Id of the group.\n  /// @param depth: Depth of the tree.\n  /// @param zeroValue: Zero value of the tree.\n  event GroupCreated(uint256 indexed groupId, uint8 depth, uint256 zeroValue);\n\n  /// @dev Emitted when a new identity commitment is added.\n  /// @param groupId: Group id of the group.\n  /// @param identityCommitment: New identity commitment.\n  /// @param root: New root hash of the tree.\n  event MemberAdded(uint256 indexed groupId, uint256 identityCommitment, uint256 root);\n\n  /// @dev Emitted when a new identity commitment is removed.\n  /// @param groupId: Group id of the group.\n  /// @param identityCommitment: New identity commitment.\n  /// @param root: New root hash of the tree.\n  event MemberRemoved(uint256 indexed groupId, uint256 identityCommitment, uint256 root);\n\n  /// @dev Returns the last root hash of a group.\n  /// @param groupId: Id of the group.\n  /// @return Root hash of the group.\n  function getRoot(uint256 groupId) external view returns (uint256);\n\n  /// @dev Returns the depth of the tree of a group.\n  /// @param groupId: Id of the group.\n  /// @return Depth of the group tree.\n  function getDepth(uint256 groupId) external view returns (uint8);\n\n  /// @dev Returns the number of tree leaves of a group.\n  /// @param groupId: Id of the group.\n  /// @return Number of tree leaves.\n  function getNumberOfLeaves(uint256 groupId) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/zk-kit/packages/incremental-merkle-tree.sol/contracts/Hashes.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nlibrary PoseidonT3 {\n  function poseidon(uint256[2] memory) public pure returns (uint256) {}\n}\n\nlibrary PoseidonT6 {\n  function poseidon(uint256[5] memory) public pure returns (uint256) {}\n}\n"
    },
    "contracts/zk-kit/packages/incremental-merkle-tree.sol/contracts/IncrementalQuinTree.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {PoseidonT6} from \"./Hashes.sol\";\n\n// Each incremental tree has certain properties and data that will\n// be used to add new leaves.\nstruct IncrementalTreeData {\n  uint8 depth; // Depth of the tree (levels - 1).\n  uint256 root; // Root hash of the tree.\n  uint256 numberOfLeaves; // Number of leaves of the tree.\n  mapping(uint256 => uint256) zeroes; // Zero hashes used for empty nodes (level -> zero hash).\n  // The nodes of the subtrees used in the last addition of a leaf (level -> [nodes]).\n  mapping(uint256 => uint256[5]) lastSubtrees; // Caching these values is essential to efficient appends.\n}\n\n/// @title Incremental quin Merkle tree.\n/// @dev The incremental tree allows to calculate the root hash each time a leaf is added, ensuring\n/// the integrity of the tree.\nlibrary IncrementalQuinTree {\n  uint8 internal constant MAX_DEPTH = 32;\n  uint256 internal constant SNARK_SCALAR_FIELD =\n    21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n  /// @dev Initializes a tree.\n  /// @param self: Tree data.\n  /// @param depth: Depth of the tree.\n  /// @param zero: Zero value to be used.\n  function init(\n    IncrementalTreeData storage self,\n    uint8 depth,\n    uint256 zero\n  ) public {\n    require(zero < SNARK_SCALAR_FIELD, \"IncrementalBinaryTree: leaf must be < SNARK_SCALAR_FIELD\");\n    require(depth > 0 && depth <= MAX_DEPTH, \"IncrementalQuinTree: tree depth must be between 1 and 32\");\n\n    self.depth = depth;\n\n    for (uint8 i = 0; i < depth; i++) {\n      self.zeroes[i] = zero;\n      uint256[5] memory zeroChildren;\n\n      for (uint8 j = 0; j < 5; j++) {\n        zeroChildren[j] = zero;\n      }\n\n      zero = PoseidonT6.poseidon(zeroChildren);\n    }\n\n    self.root = zero;\n  }\n\n  /// @dev Inserts a leaf in the tree.\n  /// @param self: Tree data.\n  /// @param leaf: Leaf to be inserted.\n  function insert(IncrementalTreeData storage self, uint256 leaf) public returns (uint256) {\n    require(leaf < SNARK_SCALAR_FIELD, \"IncrementalQuinTree: leaf must be < SNARK_SCALAR_FIELD\");\n    require(self.numberOfLeaves < 5**self.depth, \"IncrementalQuinTree: tree is full\");\n\n    uint256 index = self.numberOfLeaves;\n    uint256 hash = leaf;\n\n    for (uint8 i = 0; i < self.depth; i++) {\n      uint8 position = uint8(index % 5);\n\n      self.lastSubtrees[i][position] = hash;\n\n      if (position == 0) {\n        for (uint8 j = 1; j < 5; j++) {\n          self.lastSubtrees[i][j] = self.zeroes[i];\n        }\n      }\n\n      hash = PoseidonT6.poseidon(self.lastSubtrees[i]);\n      index /= 5;\n    }\n\n    self.root = hash;\n    self.numberOfLeaves += 1;\n    return index;\n  }\n\n  /// @dev Removes a leaf from the tree.\n  /// @param self: Tree data.\n  /// @param leaf: Leaf to be removed.\n  /// @param proofSiblings: Array of the sibling nodes of the proof of membership.\n  /// @param proofPathIndices: Path of the proof of membership.\n  function remove(\n    IncrementalTreeData storage self,\n    uint256 leaf,\n    uint256[4][] calldata proofSiblings,\n    uint8[] calldata proofPathIndices\n  ) public {\n    require(verify(self, leaf, proofSiblings, proofPathIndices), \"IncrementalQuinTree: leaf is not part of the tree\");\n\n    uint256 hash = self.zeroes[0];\n\n    for (uint8 i = 0; i < self.depth; i++) {\n      uint256[5] memory nodes;\n\n      for (uint8 j = 0; j < 5; j++) {\n        if (j < proofPathIndices[i]) {\n          nodes[j] = proofSiblings[i][j];\n        } else if (j == proofPathIndices[i]) {\n          nodes[j] = hash;\n        } else {\n          nodes[j] = proofSiblings[i][j - 1];\n        }\n      }\n\n      if (nodes[0] == self.lastSubtrees[i][0] || nodes[4] == self.lastSubtrees[i][4]) {\n        self.lastSubtrees[i][proofPathIndices[i]] = hash;\n      }\n\n      hash = PoseidonT6.poseidon(nodes);\n    }\n\n    self.root = hash;\n  }\n\n  /// @dev Verify if the path is correct and the leaf is part of the tree.\n  /// @param self: Tree data.\n  /// @param leaf: Leaf to be removed.\n  /// @param proofSiblings: Array of the sibling nodes of the proof of membership.\n  /// @param proofPathIndices: Path of the proof of membership.\n  /// @return True or false.\n  function verify(\n    IncrementalTreeData storage self,\n    uint256 leaf,\n    uint256[4][] calldata proofSiblings,\n    uint8[] calldata proofPathIndices\n  ) private view returns (bool) {\n    require(leaf < SNARK_SCALAR_FIELD, \"IncrementalQuinTree: leaf must be < SNARK_SCALAR_FIELD\");\n    require(\n      proofPathIndices.length == self.depth && proofSiblings.length == self.depth,\n      \"IncrementalQuinTree: length of path is not correct\"\n    );\n\n    uint256 hash = leaf;\n\n    for (uint8 i = 0; i < self.depth; i++) {\n      uint256[5] memory nodes;\n\n      for (uint8 j = 0; j < 5; j++) {\n        if (j < proofPathIndices[i]) {\n          require(\n            proofSiblings[i][j] < SNARK_SCALAR_FIELD,\n            \"IncrementalQuinTree: sibling node must be < SNARK_SCALAR_FIELD\"\n          );\n\n          nodes[j] = proofSiblings[i][j];\n        } else if (j == proofPathIndices[i]) {\n          nodes[j] = hash;\n        } else {\n          require(\n            proofSiblings[i][j - 1] < SNARK_SCALAR_FIELD,\n            \"IncrementalQuinTree: sibling node must be < SNARK_SCALAR_FIELD\"\n          );\n\n          nodes[j] = proofSiblings[i][j - 1];\n        }\n      }\n\n      hash = PoseidonT6.poseidon(nodes);\n    }\n\n    return hash == self.root;\n  }\n}\n"
    },
    "contracts/zk-kit/packages/incremental-merkle-tree.sol/contracts/QuinTreeTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport \"./IncrementalQuinTree.sol\";\n\ncontract QuinTreeTest {\n  using IncrementalQuinTree for IncrementalTreeData;\n\n  event TreeCreated(bytes32 id, uint8 depth);\n  event LeafInserted(bytes32 indexed treeId, uint256 leaf, uint256 root);\n  event LeafRemoved(bytes32 indexed treeId, uint256 leaf, uint256 root);\n\n  mapping(bytes32 => IncrementalTreeData) public trees;\n\n  function createTree(bytes32 _id, uint8 _depth) external {\n    require(trees[_id].depth == 0, \"QuinTreeTest: tree already exists\");\n\n    trees[_id].init(_depth, 0);\n\n    emit TreeCreated(_id, _depth);\n  }\n\n  function insertLeaf(bytes32 _treeId, uint256 _leaf) external {\n    require(trees[_treeId].depth != 0, \"QuinTreeTest: tree does not exist\");\n\n    trees[_treeId].insert(_leaf);\n\n    emit LeafInserted(_treeId, _leaf, trees[_treeId].root);\n  }\n\n  function removeLeaf(\n    bytes32 _treeId,\n    uint256 _leaf,\n    uint256[4][] calldata _proofSiblings,\n    uint8[] calldata _proofPathIndices\n  ) external {\n    require(trees[_treeId].depth != 0, \"QuinTreeTest: tree does not exist\");\n\n    trees[_treeId].remove(_leaf, _proofSiblings, _proofPathIndices);\n\n    emit LeafRemoved(_treeId, _leaf, trees[_treeId].root);\n  }\n}\n"
    },
    "contracts/zk-kit/packages/incremental-merkle-tree.sol/contracts/BinaryTreeTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport \"./IncrementalBinaryTree.sol\";\n\ncontract BinaryTreeTest {\n  using IncrementalBinaryTree for IncrementalTreeData;\n\n  event TreeCreated(bytes32 id, uint8 depth);\n  event LeafInserted(bytes32 indexed treeId, uint256 leaf, uint256 root);\n  event LeafRemoved(bytes32 indexed treeId, uint256 leaf, uint256 root);\n\n  mapping(bytes32 => IncrementalTreeData) public trees;\n\n  function createTree(bytes32 _id, uint8 _depth) external {\n    require(trees[_id].depth == 0, \"BinaryTreeTest: tree already exists\");\n\n    trees[_id].init(_depth, 0);\n\n    emit TreeCreated(_id, _depth);\n  }\n\n  function insertLeaf(bytes32 _treeId, uint256 _leaf) external {\n    require(trees[_treeId].depth != 0, \"BinaryTreeTest: tree does not exist\");\n\n    trees[_treeId].insert(_leaf);\n\n    emit LeafInserted(_treeId, _leaf, trees[_treeId].root);\n  }\n\n  function removeLeaf(\n    bytes32 _treeId,\n    uint256 _leaf,\n    uint256[] calldata _proofSiblings,\n    uint8[] calldata _proofPathIndices\n  ) external {\n    require(trees[_treeId].depth != 0, \"BinaryTreeTest: tree does not exist\");\n\n    trees[_treeId].remove(_leaf, _proofSiblings, _proofPathIndices);\n\n    emit LeafRemoved(_treeId, _leaf, trees[_treeId].root);\n  }\n}\n"
    },
    "contracts/semaphore/contracts/extensions/SemaphoreWhistleblowing.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ISemaphoreWhistleblowing.sol\";\nimport \"../base/SemaphoreCore.sol\";\nimport \"../base/SemaphoreGroups.sol\";\n\n/// @title Semaphore whistleblowing contract.\n/// @dev The following code allows you to create entities for whistleblowers (e.g. non-profit\n/// organization, newspaper) and to allow them to publish news leaks anonymously.\n/// Leaks can be IPFS hashes, permanent links or other kinds of reference.\ncontract SemaphoreWhistleblowing is ISemaphoreWhistleblowing, SemaphoreCore, SemaphoreGroups {\n  /// @dev Gets a tree depth and returns its verifier address.\n  mapping(uint8 => IVerifier) internal verifiers;\n\n  /// @dev Gets an editor address and return their entity.\n  mapping(address => uint256) private entities;\n\n  /// @dev Since there can be multiple verifier contracts (each associated with a certain tree depth),\n  /// it is necessary to pass the addresses of the previously deployed contracts with the associated\n  /// tree depth. Depending on the depth chosen when creating the entity, a certain verifier will be\n  /// used to verify that the proof is correct.\n  /// @param depths: Three depths used in verifiers.\n  /// @param verifierAddresses: Verifier addresses.\n  constructor(uint8[] memory depths, address[] memory verifierAddresses) {\n    require(\n      depths.length == verifierAddresses.length,\n      \"SemaphoreWhistleblowing: parameters lists does not have the same length\"\n    );\n\n    for (uint8 i = 0; i < depths.length; i++) {\n      verifiers[depths[i]] = IVerifier(verifierAddresses[i]);\n    }\n  }\n\n  /// @dev Checks if the editor is the transaction sender.\n  /// @param entityId: Id of the entity.\n  modifier onlyEditor(uint256 entityId) {\n    require(entityId == entities[_msgSender()], \"SemaphoreWhistleblowing: caller is not the editor\");\n    _;\n  }\n\n  /// @dev See {ISemaphoreWhistleblowing-createEntity}.\n  function createEntity(\n    uint256 entityId,\n    address editor,\n    uint8 depth\n  ) public override {\n    require(address(verifiers[depth]) != address(0), \"SemaphoreWhistleblowing: depth value is not supported\");\n\n    _createGroup(entityId, depth, 0);\n\n    entities[editor] = entityId;\n\n    emit EntityCreated(entityId, editor);\n  }\n\n  /// @dev See {ISemaphoreWhistleblowing-addWhistleblower}.\n  function addWhistleblower(uint256 entityId, uint256 identityCommitment) public override onlyEditor(entityId) {\n    _addMember(entityId, identityCommitment);\n  }\n\n  /// @dev See {ISemaphoreWhistleblowing-removeWhistleblower}.\n  function removeWhistleblower(\n    uint256 entityId,\n    uint256 identityCommitment,\n    uint256[] calldata proofSiblings,\n    uint8[] calldata proofPathIndices\n  ) public override onlyEditor(entityId) {\n    _removeMember(entityId, identityCommitment, proofSiblings, proofPathIndices);\n  }\n\n  /// @dev See {ISemaphoreWhistleblowing-publishLeak}.\n  function publishLeak(\n    bytes32 leak,\n    uint256 nullifierHash,\n    uint256 entityId,\n    uint256[8] calldata proof\n  ) public override onlyEditor(entityId) {\n    uint8 depth = getDepth(entityId);\n    uint256 root = getRoot(entityId);\n    IVerifier verifier = verifiers[depth];\n\n    _verifyProof(leak, root, nullifierHash, entityId, proof, verifier);\n\n    emit LeakPublished(entityId, leak);\n  }\n}\n"
    },
    "contracts/semaphore/contracts/interfaces/ISemaphoreWhistleblowing.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.4;\n\n/// @title SemaphoreWhistleblowing interface.\n/// @dev Interface of SemaphoreWhistleblowing contract.\ninterface ISemaphoreWhistleblowing {\n  /// @dev Emitted when a new entity is created.\n  /// @param entityId: Id of the entity.\n  /// @param editor: Editor of the entity.\n  event EntityCreated(uint256 entityId, address indexed editor);\n\n  /// @dev Emitted when a whistleblower publish a new leak.\n  /// @param entityId: Id of the entity.\n  /// @param leak: News leak.\n  event LeakPublished(uint256 indexed entityId, bytes32 leak);\n\n  /// @dev Creates an entity and the associated Merkle tree/group.\n  /// @param entityId: Id of the entity.\n  /// @param editor: Editor of the entity.\n  /// @param depth: Depth of the tree.\n  function createEntity(\n    uint256 entityId,\n    address editor,\n    uint8 depth\n  ) external;\n\n  /// @dev Adds a whistleblower to an entity.\n  /// @param entityId: Id of the entity.\n  /// @param identityCommitment: Identity commitment of the group member.\n  function addWhistleblower(uint256 entityId, uint256 identityCommitment) external;\n\n  /// @dev Removes a whistleblower from an entity.\n  /// @param entityId: Id of the entity.\n  /// @param identityCommitment: Identity commitment of the group member.\n  /// @param proofSiblings: Array of the sibling nodes of the proof of membership.\n  /// @param proofPathIndices: Path of the proof of membership.\n  function removeWhistleblower(\n    uint256 entityId,\n    uint256 identityCommitment,\n    uint256[] calldata proofSiblings,\n    uint8[] calldata proofPathIndices\n  ) external;\n\n  /// @dev Allows whistleblowers to publish leaks anonymously.\n  /// @param leak: News leak.\n  /// @param nullifierHash: Nullifier hash.\n  /// @param entityId: Id of the entity.\n  /// @param proof: Private zk-proof parameters.\n  function publishLeak(\n    bytes32 leak,\n    uint256 nullifierHash,\n    uint256 entityId,\n    uint256[8] calldata proof\n  ) external;\n}\n"
    },
    "contracts/semaphore/contracts/extensions/SemaphoreVoting.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ISemaphoreVoting.sol\";\nimport \"../base/SemaphoreCore.sol\";\nimport \"../base/SemaphoreGroups.sol\";\n\n/// @title Semaphore voting contract.\n/// @dev The following code allows you to create polls, add voters and allow them to vote anonymously.\ncontract SemaphoreVoting is ISemaphoreVoting, SemaphoreCore, SemaphoreGroups {\n  /// @dev Gets a tree depth and returns its verifier address.\n  mapping(uint8 => IVerifier) internal verifiers;\n\n  /// @dev Gets a poll id and returns the poll data.\n  mapping(uint256 => Poll) internal polls;\n\n  /// @dev Since there can be multiple verifier contracts (each associated with a certain tree depth),\n  /// it is necessary to pass the addresses of the previously deployed contracts with the associated\n  /// tree depth. Depending on the depth chosen when creating the poll, a certain verifier will be\n  /// used to verify that the proof is correct.\n  /// @param depths: Three depths used in verifiers.\n  /// @param verifierAddresses: Verifier addresses.\n  constructor(uint8[] memory depths, address[] memory verifierAddresses) {\n    require(\n      depths.length == verifierAddresses.length,\n      \"SemaphoreVoting: parameters lists does not have the same length\"\n    );\n\n    for (uint8 i = 0; i < depths.length; i++) {\n      verifiers[depths[i]] = IVerifier(verifierAddresses[i]);\n    }\n  }\n\n  /// @dev Checks if the poll coordinator is the transaction sender.\n  /// @param pollId: Id of the poll.\n  modifier onlyCoordinator(uint256 pollId) {\n    require(polls[pollId].coordinator == _msgSender(), \"SemaphoreVoting: caller is not the poll coordinator\");\n    _;\n  }\n\n  /// @dev See {ISemaphoreVoting-createPoll}.\n  function createPoll(\n    uint256 pollId,\n    address coordinator,\n    uint8 depth\n  ) public override {\n    require(address(verifiers[depth]) != address(0), \"SemaphoreVoting: depth value is not supported\");\n\n    _createGroup(pollId, depth, 0);\n\n    Poll memory poll;\n\n    poll.coordinator = coordinator;\n\n    polls[pollId] = poll;\n\n    emit PollCreated(pollId, coordinator);\n  }\n\n  /// @dev See {ISemaphoreVoting-addVoter}.\n  function addVoter(uint256 pollId, uint256 identityCommitment) public override onlyCoordinator(pollId) {\n    require(polls[pollId].state == PollState.Created, \"SemaphoreVoting: voters can only be added before voting\");\n\n    _addMember(pollId, identityCommitment);\n  }\n\n  /// @dev See {ISemaphoreVoting-addVoter}.\n  function startPoll(uint256 pollId, uint256 encryptionKey) public override onlyCoordinator(pollId) {\n    require(polls[pollId].state == PollState.Created, \"SemaphoreVoting: poll has already been started\");\n\n    polls[pollId].state = PollState.Ongoing;\n\n    emit PollStarted(pollId, _msgSender(), encryptionKey);\n  }\n\n  /// @dev See {ISemaphoreVoting-castVote}.\n  function castVote(\n    bytes32 vote,\n    uint256 nullifierHash,\n    uint256 pollId,\n    uint256[8] calldata proof\n  ) public override onlyCoordinator(pollId) {\n    Poll memory poll = polls[pollId];\n\n    require(poll.state == PollState.Ongoing, \"SemaphoreVoting: vote can only be cast in an ongoing poll\");\n\n    uint8 depth = getDepth(pollId);\n    uint256 root = getRoot(pollId);\n    IVerifier verifier = verifiers[depth];\n\n    _verifyProof(vote, root, nullifierHash, pollId, proof, verifier);\n\n    // Prevent double-voting (nullifierHash = hash(pollId + identityNullifier)).\n    _saveNullifierHash(nullifierHash);\n\n    emit VoteAdded(pollId, vote);\n  }\n\n  /// @dev See {ISemaphoreVoting-publishDecryptionKey}.\n  function endPoll(uint256 pollId, uint256 decryptionKey) public override onlyCoordinator(pollId) {\n    require(polls[pollId].state == PollState.Ongoing, \"SemaphoreVoting: poll is not ongoing\");\n\n    polls[pollId].state = PollState.Ended;\n\n    emit PollEnded(pollId, _msgSender(), decryptionKey);\n  }\n}\n"
    },
    "contracts/semaphore/contracts/interfaces/ISemaphoreVoting.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.4;\n\n/// @title SemaphoreVoting interface.\n/// @dev Interface of SemaphoreVoting contract.\ninterface ISemaphoreVoting {\n  enum PollState {\n    Created,\n    Ongoing,\n    Ended\n  }\n\n  struct Poll {\n    address coordinator;\n    PollState state;\n  }\n\n  /// @dev Emitted when a new poll is created.\n  /// @param pollId: Id of the poll.\n  /// @param coordinator: Coordinator of the poll.\n  event PollCreated(uint256 pollId, address indexed coordinator);\n\n  /// @dev Emitted when a poll is started.\n  /// @param pollId: Id of the poll.\n  /// @param coordinator: Coordinator of the poll.\n  /// @param encryptionKey: Key to encrypt the poll votes.\n  event PollStarted(uint256 pollId, address indexed coordinator, uint256 encryptionKey);\n\n  /// @dev Emitted when a user votes on a poll.\n  /// @param pollId: Id of the poll.\n  /// @param vote: User encrypted vote.\n  event VoteAdded(uint256 indexed pollId, bytes32 vote);\n\n  /// @dev Emitted when a poll is ended.\n  /// @param pollId: Id of the poll.\n  /// @param coordinator: Coordinator of the poll.\n  /// @param decryptionKey: Key to decrypt the poll votes.\n  event PollEnded(uint256 pollId, address indexed coordinator, uint256 decryptionKey);\n\n  /// @dev Creates a poll and the associated Merkle tree/group.\n  /// @param pollId: Id of the poll.\n  /// @param coordinator: Coordinator of the poll.\n  /// @param depth: Depth of the tree.\n  function createPoll(\n    uint256 pollId,\n    address coordinator,\n    uint8 depth\n  ) external;\n\n  /// @dev Adds a voter to a poll.\n  /// @param pollId: Id of the poll.\n  /// @param identityCommitment: Identity commitment of the group member.\n  function addVoter(uint256 pollId, uint256 identityCommitment) external;\n\n  /// @dev Starts a pull and publishes the key to encrypt the votes.\n  /// @param pollId: Id of the poll.\n  /// @param encryptionKey: Key to encrypt poll votes.\n  function startPoll(uint256 pollId, uint256 encryptionKey) external;\n\n  /// @dev Casts an anonymous vote in a poll.\n  /// @param vote: Encrypted vote.\n  /// @param nullifierHash: Nullifier hash.\n  /// @param pollId: Id of the poll.\n  /// @param proof: Private zk-proof parameters.\n  function castVote(\n    bytes32 vote,\n    uint256 nullifierHash,\n    uint256 pollId,\n    uint256[8] calldata proof\n  ) external;\n\n  /// @dev Ends a pull and publishes the key to decrypt the votes.\n  /// @param pollId: Id of the poll.\n  /// @param decryptionKey: Key to decrypt poll votes.\n  function endPoll(uint256 pollId, uint256 decryptionKey) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/DummyToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./interfaces/AggregatorV3Interface.sol\";\n\ncontract DummyToken is ERC20 {\n    \n    address public priceFeed;\n    address immutable owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Caller is not the owner\");\n        _;\n    }\n\n    constructor(\n        string memory name,\n        string memory symbol\n    ) ERC20(name, symbol) {\n        _mint(msg.sender, 1000 * 10e18);\n        owner = msg.sender;\n    }\n\n    function setPriceFeed(address _priceFeed) external onlyOwner {\n        require (_priceFeed != priceFeed,\"new address is same as current one\");\n        require (_priceFeed != address(0),\"zero address not allowed\");\n        priceFeed = _priceFeed;\n    }\n\n    function getPrice() public view returns(uint256){\n        (, int256 _iprice, , , ) = AggregatorV3Interface(priceFeed)\n            .latestRoundData();\n        uint256 _price = uint256(_iprice);\n        return uint256(_price);\n    }\n}\n"
    },
    "contracts/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    // getRoundData and latestRoundData should both raise \"No data present\"\n    // if they do not have data to report, instead of returning unset values\n    // which could be misinterpreted as actual reported values.\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n"
    },
    "contracts/mock/MockChainlinkOracleFeed.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.1\npragma solidity ^0.8.0;\n\nimport \"../interfaces/AggregatorV3Interface.sol\";\n\ncontract MockChainlinkOracleFeed is AggregatorV3Interface {\n    int256 price;\n    uint8 numDecimals;\n\n    constructor(int256 _price, uint8 _decimals) {\n        price = _price;\n        numDecimals = _decimals;\n    }\n\n    function decimals() external view override returns (uint8) {\n        return numDecimals;\n    }\n\n    function description() external pure override returns (string memory) {\n        return \"MockOracleEthFeed\";\n    }\n\n    function version() external pure override returns (uint256) {\n        return 1;\n    }\n\n    function setPrice(int256 _price) public {\n        price = _price;\n    }\n\n    function setDecimals(uint8 _decimals) public {\n        numDecimals = _decimals;\n    }\n\n    // getRoundData and latestRoundData should both raise \"No data present\"\n    // if they do not have data to report, instead of returning unset values\n    // which could be misinterpreted as actual reported values.\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        roundId = _roundId;\n        answer = price;\n        startedAt = 0;\n        updatedAt = 0;\n        answeredInRound = 0;\n    }\n\n    function latestRoundData()\n        external\n        view\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        roundId = 0;\n        answer = price;\n        startedAt = 0;\n        updatedAt = 0;\n        answeredInRound = 0;\n    }\n}\n"
    },
    "contracts/JomTx.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport { ByteHasher } from './helpers/ByteHasher.sol';\nimport { IWorldID } from './interfaces/IWorldID.sol';\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\n/*\n//   @dev JomTx contract, implemented for ETH SF hackathon\n//   @title JomTx\n//   @author Carlos Ramos\n//   @note we infer that everyStore using this contract has already been verified.\n*/\ncontract JomTx {\n    using ByteHasher for bytes;\n    using Counters for Counters.Counter;\n\n    /// @notice Thrown when attempting to reuse a nullifier\n    error InvalidNullifier();\n    error UserVerified();\n    error UserNotVerified();\n\n    event transactionSubmitted(uint256 identityCommitment, string ipfs_uri, address buyer_addr, string detail);\n\n    /// @dev The WorldID instance that will be used for verifying proofs\n    IWorldID internal immutable worldId;\n\n    /// @dev The application's action ID\n    uint256 internal immutable actionId;\n\n    /// @dev The WorldID group ID (1)\n    uint256 internal immutable groupId = 1;\n\n    /// @dev Whether a nullifier hash has been used already. Used to prevent double-signaling\n    mapping(uint256 => bool) internal nullifierHashes;\n    mapping(address => bool) public registeredUser;\n\n    // PROTOCOL VARIABLES //\n    mapping(uint256 => string[]) internal storeTransactions;\n    mapping(address => string[]) internal userTransactions;\n\n    Counters.Counter private groupIds;\n\n    /// @param _worldId The WorldID instance that will verify the proofs\n    /// @param _actionId The action ID for your application\n    constructor(IWorldID _worldId, string memory _actionId) {\n        worldId = _worldId;\n        actionId = abi.encodePacked(_actionId).hashToField();\n    }\n\n    /// @dev if store is verified\n    function submitNonVerifiedUserTx (\n        string memory ipfs_uri,\n        string memory detail,\n        uint256 storeSignal,\n        uint256 root,\n        uint256 nullifierHash,\n        uint256[8] calldata proof \n        ) external {\n\n        storeTransactions[nullifierHash].push(ipfs_uri);\n\n        worldId.verifyProof(\n            root,\n            groupId,\n            abi.encodePacked(storeSignal).hashToField(),\n            nullifierHash,\n            actionId,\n            proof\n        );\n\n        emit transactionSubmitted(nullifierHash, ipfs_uri, address(0),detail);\n    }\n\n    /// @dev iff user and store are both verified\n    function submitVerifiedTx (\n        string memory ipfs_uri,\n        string memory detail,\n        address buyer_addr,\n        address storeSignal,\n        uint256 root,\n        uint256 nullifierHash,\n        uint256[8] calldata proof\n        ) external {\n\n        require(registeredUser[buyer_addr], \"User hasnt been verified\");\n\n        worldId.verifyProof(\n            root,\n            groupId,\n            abi.encodePacked(storeSignal).hashToField(),\n            nullifierHash,\n            actionId,\n            proof\n        );\n\n        storeTransactions[nullifierHash].push(ipfs_uri);\n        userTransactions[buyer_addr].push(ipfs_uri);\n\n        emit transactionSubmitted(nullifierHash, ipfs_uri, buyer_addr,detail);\n    }\n\n    function verifyUser (\n        address callerAddr,\n        uint256 root,\n        uint256 nullifierHash,\n        uint256[8] calldata proof\n    ) external {\n        if (nullifierHashes[nullifierHash]) revert InvalidNullifier();\n        if (registeredUser[msg.sender]) revert UserVerified();\n\n        worldId.verifyProof(\n            root,\n            groupId,\n            abi.encodePacked(callerAddr).hashToField(),\n            nullifierHash,\n            actionId,\n            proof\n        );\n\n        nullifierHashes[nullifierHash] = true;\n        registeredUser[msg.sender] = true;\n    }\n\n    function verifyForTaxDeclaration(\n        address callerAddr, \n        uint256 root,\n        uint256 nullifierHash,\n        uint256[8] calldata proof\n    ) external {\n        if (registeredUser[msg.sender]) revert UserNotVerified();\n\n        worldId.verifyProof(\n            root,\n            groupId,\n            abi.encodePacked(callerAddr).hashToField(),\n            nullifierHash,\n            actionId,\n            proof\n        );\n    }\n\n    function getCurrGroupId() external view returns(uint256) {\n        return groupIds.current();\n    }\n\n    function incrementGroupIds() external {\n        groupIds.increment();\n    }\n\n\n    function getWorldIDAddr () external view returns(address){\n        return address(worldId);\n    }\n}"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "contracts/UserRegistry.sol": {
      "content": "pragma solidity ^0.8.0;\n//version C\ncontract UserRegistry {\n    uint256 public userCount;\n    address immutable owner;\n    struct User {\n        string url;\n        string name;\n        uint256 involvementBasis;\n        uint256 imgType;\n    }\n    \n    mapping(address => User) userByAddress;\n    modifier onlyOwner () {\n        require(msg.sender == owner , \"caller is not owner\");\n        _;\n    }\n    constructor () {\n        owner = msg.sender;\n\n    }\n    function getUserByAddress() external view returns (User memory myUser){\n        myUser = userByAddress[msg.sender];\n    }\n    function modifyUser(string memory _url, string memory _name, uint256 _imgType) external {\n        User storage newUser = userByAddress[msg.sender];\n        newUser.url  = _url;\n        newUser.name = _name;\n        newUser.imgType = _imgType;\n    }\n\n    function getRandom() public view returns (bytes32 addr) {\n        assembly {\n            let freemem := mload(0x40)\n            let start_addr := add(freemem, 0)\n            if iszero(staticcall(gas(), 0x18, 0, 0, start_addr, 32)) {\n              invalid()\n            }\n            addr := mload(freemem)\n        }\n    }\n}"
    },
    "contracts/semaphore/contracts/interfaces/ISemaphoreNullifiers.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.4;\n\n/// @title SemaphoreNullifiers interface.\n/// @dev Interface of SemaphoreNullifiers contract.\ninterface ISemaphoreNullifiers {\n  /// @dev Emitted when a external nullifier is added.\n  /// @param externalNullifier: External Semaphore nullifier.\n  event ExternalNullifierAdded(uint256 externalNullifier);\n\n  /// @dev Emitted when a external nullifier is removed.\n  /// @param externalNullifier: External Semaphore nullifier.\n  event ExternalNullifierRemoved(uint256 externalNullifier);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}